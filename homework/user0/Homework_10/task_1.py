'''
Задание №1
Создайте универсальный декоратор, который можно будет применить к любой функции.
Декоратор должен делать следующее: он должен распечатывать слово "finished"
после выполнения декорированной функции.

Код, использующий этот декоратор может выглядеть, например, так:

@finish_me
def example(text):
    print(text)

example('print me')
В результате работы будет такое:

print me

finished
'''


def finish_me(func):
    '''
    Создаём функцию-декоратор finish_me, которая принимает в качестве аргумента
    другую функцию func, чтобы добавить к ней дополнительные действия.
    '''
    def wrapper(*args, **kwargs):
        '''
        Внутри finish_me создаём вложенную функцию wrapper, которая оборачивает
        логику переданной функции func. *args и **kwargs позволяют принимать
        произвольные позиционные и именованные аргументы, чтобы декоратор работал
        с любой функцией.
        '''
        # Выполняем саму функцию
        result = func(*args, **kwargs)
        # Печатаем слово "finished" после завершения функции
        print("finished")
        # Возвращаем результат функции
        return result
    return wrapper


# Пример использования
@finish_me
def example(text):
    '''
    Применяем декоратор @finish_me к функции example.
    Это эквивалентно example = finish_me(example), то есть функция example
    теперь будет выполняться через wrapper.
    '''
    print(text)


example('print me')
